{
    "sourceFile": "lib/environmental-service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 29,
            "patches": [
                {
                    "date": 1736980309721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1736980326954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,10 +110,21 @@\n     if (!apiKey) {\n       throw new Error('Tomorrow.io API key not configured');\n     }\n \n-    const url = `https://api.tomorrow.io/v4/timelines?location=42.36,-71.06&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n+    // Get user's location\n+    let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n+    try {\n+      const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n+        navigator.geolocation.getCurrentPosition(resolve, reject);\n+      });\n+      location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n+    } catch (error) {\n+      console.warn('Failed to get user location, using default:', error);\n+    }\n \n+    const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n+\n     try {\n       const response = await fetch(url);\n       const data = await response.json();\n       \n"
                },
                {
                    "date": 1736980347081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,13 +114,49 @@\n     // Get user's location\n     let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n     try {\n       const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n-        navigator.geolocation.getCurrentPosition(resolve, reject);\n+        if (!navigator.geolocation) {\n+          reject(new Error('Geolocation not supported'));\n+          return;\n+        }\n+        \n+        navigator.geolocation.getCurrentPosition(\n+          resolve,\n+          (error) => {\n+            // Handle different error cases\n+            switch (error.code) {\n+              case error.PERMISSION_DENIED:\n+                reject(new Error('User denied geolocation permission'));\n+                break;\n+              case error.POSITION_UNAVAILABLE:\n+                reject(new Error('Location information is unavailable'));\n+                break;\n+              case error.TIMEOUT:\n+                reject(new Error('The request to get user location timed out'));\n+                break;\n+              default:\n+                reject(new Error('An unknown error occurred'));\n+            }\n+          },\n+          {\n+            enableHighAccuracy: true,\n+            timeout: 5000,\n+            maximumAge: 0\n+          }\n+        );\n       });\n       location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n     } catch (error) {\n       console.warn('Failed to get user location, using default:', error);\n+      // Try to get location from IP as fallback\n+      try {\n+        const ipResponse = await fetch('https://ipapi.co/json/');\n+        const ipData = await ipResponse.json();\n+        location = { lat: ipData.latitude, lng: ipData.longitude };\n+      } catch (ipError) {\n+        console.warn('Failed to get location from IP, using default:', ipError);\n+      }\n     }\n \n     const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n"
                },
                {
                    "date": 1736980394713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,38 +159,73 @@\n     }\n \n     const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n+    // Cache weather data for 5 minutes to avoid excessive API calls\n+    const cacheKey = `weather-${location.lat}-${location.lng}`;\n+    const cachedData = sessionStorage.getItem(cacheKey);\n+    \n+    if (cachedData) {\n+      const { timestamp, data } = JSON.parse(cachedData);\n+      if (Date.now() - timestamp < 5 * 60 * 1000) {\n+        return this.transformWeatherData(data);\n+      }\n+    }\n+\n     try {\n       const response = await fetch(url);\n+      if (!response.ok) {\n+        throw new Error(`API request failed with status ${response.status}`);\n+      }\n+      \n       const data = await response.json();\n-      \n       const current = data?.data?.timelines[0]?.intervals[0]?.values;\n       if (!current) {\n         throw new Error('Invalid weather data received');\n       }\n \n-      return {\n-        temperature: current.temperature,\n-        humidity: current.humidity,\n-        altitude: this.conditions.altitude, // Keep using local altitude\n-        windSpeed: current.windSpeed,\n-        windDirection: current.windDirection,\n-        pressure: current.pressure,\n-        density: EnvironmentalCalculator.calculateAirDensity({\n-          temperature: current.temperature,\n-          humidity: current.humidity,\n-          pressure: current.pressure,\n-          altitude: this.conditions.altitude,\n-          windSpeed: current.windSpeed,\n-          windDirection: current.windDirection,\n-          density: 1.225\n-        })\n-      };\n+      // Cache the successful response\n+      sessionStorage.setItem(cacheKey, JSON.stringify({\n+        timestamp: Date.now(),\n+        data: current\n+      }));\n+\n+      return this.transformWeatherData(current);\n     } catch (error) {\n       console.error('Failed to fetch weather data:', error);\n+      \n+      // If we have cached data, use it even if it's stale\n+      if (cachedData) {\n+        const { data } = JSON.parse(cachedData);\n+        console.warn('Using cached weather data due to API error');\n+        return this.transformWeatherData(data);\n+      }\n+      \n       throw error;\n     }\n   }\n+\n+  private transformWeatherData(data: any): EnvironmentalConditions {\n+    return {\n+      temperature: data.temperature,\n+      humidity: data.humidity,\n+      altitude: this.conditions.altitude,\n+      windSpeed: data.windSpeed,\n+      windDirection: data.windDirection,\n+      pressure: data.pressure,\n+      density: EnvironmentalCalculator.calculateAirDensity({\n+        temperature: data.temperature,\n+        humidity: data.humidity,\n+        pressure: data.pressure,\n+        altitude: this.conditions.altitude,\n+        windSpeed: data.windSpeed,\n+        windDirection: data.windDirection,\n+        density: 1.225\n+      }),\n+      weatherCode: data.weatherCode,\n+      precipitationProbability: data.precipitationProbability,\n+      cloudCover: data.cloudCover\n+    };\n+  }\n }\n \n export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736980428144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,9 +157,9 @@\n         console.warn('Failed to get location from IP, using default:', ipError);\n       }\n     }\n \n-    const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n+    const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure,weatherCode,precipitationProbability,cloudCover&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n     const cachedData = sessionStorage.getItem(cacheKey);\n"
                },
                {
                    "date": 1736980553186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,12 +219,9 @@\n         altitude: this.conditions.altitude,\n         windSpeed: data.windSpeed,\n         windDirection: data.windDirection,\n         density: 1.225\n-      }),\n-      weatherCode: data.weatherCode,\n-      precipitationProbability: data.precipitationProbability,\n-      cloudCover: data.cloudCover\n+      })\n     };\n   }\n }\n \n"
                },
                {
                    "date": 1736980635466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,29 +49,27 @@\n   private notifySubscribers(): void {\n     this.subscribers.forEach((callback) => callback(this.conditions))\n   }\n \n-  private updateConditions(): void {\n-    const now = Date.now()\n-    const timeScale = now / (24 * 60 * 60 * 1000) // Scale to one day\n-\n-    // Update conditions with some natural variation\n-    this.conditions = {\n-      ...this.conditions,\n-      temperature: 70 + Math.sin(timeScale * Math.PI * 2) * 10, // Vary between 60-80°F\n-      humidity: 60 + Math.sin(timeScale * Math.PI * 2 + 1) * 20, // Vary between 40-80%\n-      altitude: this.baseAltitude + Math.sin(timeScale * Math.PI * 2 + 2) * 10, // Small variations\n-      pressure: 1013.25 + Math.sin(timeScale * Math.PI * 2 + 3) * 10, // Vary around standard\n-      windSpeed: Math.abs(Math.sin(timeScale * Math.PI * 2 + 4) * 15), // Vary between 0-15 mph\n-      windDirection: (Math.sin(timeScale * Math.PI * 2 + 5) * 180 + 180) % 360, // Vary between 0-360 degrees\n-      density: 0 // Will be calculated below\n+  private async updateConditions(): Promise<void> {\n+    try {\n+      const conditions = await this.getCurrentConditions();\n+      this.conditions = {\n+        ...this.conditions,\n+        temperature: conditions.temperature,\n+        humidity: conditions.humidity,\n+        pressure: conditions.pressure,\n+        windSpeed: conditions.windSpeed,\n+        windDirection: conditions.windDirection,\n+        density: conditions.density\n+      };\n+      \n+      this.lastUpdate = Date.now();\n+      this.notifySubscribers();\n+    } catch (error) {\n+      console.error('Failed to update conditions:', error);\n+      // Keep using previous conditions if API fails\n     }\n-\n-    // Calculate air density\n-    this.conditions.density = EnvironmentalCalculator.calculateAirDensity(this.conditions)\n-\n-    this.lastUpdate = now\n-    this.notifySubscribers()\n   }\n \n   public startMonitoring(): void {\n     if (!this.updateInterval) {\n"
                },
                {
                    "date": 1736980654080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,10 +72,16 @@\n   }\n \n   public startMonitoring(): void {\n     if (!this.updateInterval) {\n-      this.updateInterval = setInterval(() => this.updateConditions(), 1000)\n-      this.updateConditions() // Initial update\n+      this.updateInterval = setInterval(async () => {\n+        try {\n+          await this.updateConditions();\n+        } catch (error) {\n+          console.error('Error in monitoring interval:', error);\n+        }\n+      }, 1000 * 60 * 5); // Update every 5 minutes to avoid excessive API calls\n+      this.updateConditions(); // Initial update\n     }\n   }\n \n   public stopMonitoring(): void {\n"
                },
                {
                    "date": 1736980762439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n     const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure,weatherCode,precipitationProbability,cloudCover&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n-    const cachedData = sessionStorage.getItem(cacheKey);\n+    const cachedData = localStorage.getItem(cacheKey);\n     \n     if (cachedData) {\n       const { timestamp, data } = JSON.parse(cachedData);\n       if (Date.now() - timestamp < 5 * 60 * 1000) {\n"
                },
                {
                    "date": 1736980776683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,9 @@\n         throw new Error('Invalid weather data received');\n       }\n \n       // Cache the successful response\n-      sessionStorage.setItem(cacheKey, JSON.stringify({\n+      localStorage.setItem(cacheKey, JSON.stringify({\n         timestamp: Date.now(),\n         data: current\n       }));\n \n"
                },
                {
                    "date": 1736980822375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,8 +116,10 @@\n     }\n \n     // Get user's location\n     let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n+    let locationSource = 'default';\n+    \n     try {\n       const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n         if (!navigator.geolocation) {\n           reject(new Error('Geolocation not supported'));\n@@ -143,25 +145,37 @@\n             }\n           },\n           {\n             enableHighAccuracy: true,\n-            timeout: 5000,\n+            timeout: 2000, // Faster timeout\n             maximumAge: 0\n           }\n         );\n       });\n       location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n+      locationSource = 'geolocation';\n     } catch (error) {\n-      console.warn('Failed to get user location, using default:', error);\n+      console.warn('Failed to get precise location:', error);\n+      \n       // Try to get location from IP as fallback\n       try {\n         const ipResponse = await fetch('https://ipapi.co/json/');\n+        if (!ipResponse.ok) throw new Error('IP location service failed');\n+        \n         const ipData = await ipResponse.json();\n-        location = { lat: ipData.latitude, lng: ipData.longitude };\n+        if (ipData.latitude && ipData.longitude) {\n+          location = { lat: ipData.latitude, lng: ipData.longitude };\n+          locationSource = 'ip';\n+        } else {\n+          throw new Error('Invalid IP location data');\n+        }\n       } catch (ipError) {\n-        console.warn('Failed to get location from IP, using default:', ipError);\n+        console.warn('Failed to get approximate location:', ipError);\n+        locationSource = 'default';\n       }\n     }\n+    \n+    console.log(`Using location from ${locationSource}:`, location);\n \n     const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure,weatherCode,precipitationProbability,cloudCover&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n"
                },
                {
                    "date": 1736980871688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,8 +174,9 @@\n       }\n     }\n     \n     console.log(`Using location from ${locationSource}:`, location);\n+    console.log('Fetching weather for coordinates:', location);\n \n     const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure,weatherCode,precipitationProbability,cloudCover&timesteps=current&units=imperial&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n"
                },
                {
                    "date": 1736980885768,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,9 +207,12 @@\n         timestamp: Date.now(),\n         data: current\n       }));\n \n-      return this.transformWeatherData(current);\n+      console.log('Received weather data:', current);\n+      const transformed = this.transformWeatherData(current);\n+      console.log('Transformed weather data:', transformed);\n+      return transformed;\n     } catch (error) {\n       console.error('Failed to fetch weather data:', error);\n       \n       // If we have cached data, use it even if it's stale\n"
                },
                {
                    "date": 1736981132313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,11 +109,11 @@\n     return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n   }\n \n   async getCurrentConditions(): Promise<EnvironmentalConditions> {\n-    const apiKey = process.env.TOMORROW_API_KEY;\n+    const apiKey = process.env.NEXT_PUBLIC_TOMORROW_API_KEY;\n     if (!apiKey) {\n-      throw new Error('Tomorrow.io API key not configured');\n+      throw new Error('Tomorrow.io API key not configured. Please set NEXT_PUBLIC_TOMORROW_API_KEY in .env');\n     }\n \n     // Get user's location\n     let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n"
                },
                {
                    "date": 1736981281536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,9 +176,9 @@\n     \n     console.log(`Using location from ${locationSource}:`, location);\n     console.log('Fetching weather for coordinates:', location);\n \n-    const url = `https://api.tomorrow.io/v4/timelines?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure,weatherCode,precipitationProbability,cloudCover&timesteps=current&units=imperial&apikey=${apiKey}`;\n+    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n     const cachedData = localStorage.getItem(cacheKey);\n"
                },
                {
                    "date": 1736981297090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n         throw new Error(`API request failed with status ${response.status}`);\n       }\n       \n       const data = await response.json();\n-      const current = data?.data?.timelines[0]?.intervals[0]?.values;\n+      const current = data?.data?.values;\n       if (!current) {\n         throw new Error('Invalid weather data received');\n       }\n \n"
                },
                {
                    "date": 1736981537059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,9 +176,9 @@\n     \n     console.log(`Using location from ${locationSource}:`, location);\n     console.log('Fetching weather for coordinates:', location);\n \n-    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&apikey=${apiKey}`;\n+    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n     const cachedData = localStorage.getItem(cacheKey);\n"
                },
                {
                    "date": 1736981557495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -226,23 +226,26 @@\n     }\n   }\n \n   private transformWeatherData(data: any): EnvironmentalConditions {\n+    const pressure = data.pressure || 1013.25; // Default to standard pressure if missing\n+    const temperature = data.temperature;\n+    const humidity = data.humidity;\n+    \n     return {\n-      temperature: data.temperature,\n-      humidity: data.humidity,\n+      temperature: temperature,\n+      humidity: humidity,\n       altitude: this.conditions.altitude,\n       windSpeed: data.windSpeed,\n       windDirection: data.windDirection,\n-      pressure: data.pressure,\n+      pressure: pressure,\n       density: EnvironmentalCalculator.calculateAirDensity({\n-        temperature: data.temperature,\n-        humidity: data.humidity,\n-        pressure: data.pressure,\n+        temperature: temperature,\n+        humidity: humidity,\n+        pressure: pressure,\n         altitude: this.conditions.altitude,\n         windSpeed: data.windSpeed,\n-        windDirection: data.windDirection,\n-        density: 1.225\n+        windDirection: data.windDirection\n       })\n     };\n   }\n }\n"
                },
                {
                    "date": 1736981575829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,15 @@\n         locationSource = 'default';\n       }\n     }\n     \n-    console.log(`Using location from ${locationSource}:`, location);\n+    console.group('Location Detection');\n+    console.log(`Source: ${locationSource}`);\n+    console.log('Coordinates:', location);\n+    if (locationSource === 'ip') {\n+      console.log('City:', ipData.city, 'Region:', ipData.region);\n+    }\n+    console.groupEnd();\n     console.log('Fetching weather for coordinates:', location);\n \n     const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&apikey=${apiKey}`;\n \n"
                },
                {
                    "date": 1736981619410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,15 +156,18 @@\n     } catch (error) {\n       console.warn('Failed to get precise location:', error);\n       \n       // Try to get location from IP as fallback\n+      let ipData: any;\n       try {\n-        const ipResponse = await fetch('https://ipapi.co/json/');\n+        // Try a more reliable IP geolocation service\n+        const ipResponse = await fetch('https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f');\n         if (!ipResponse.ok) throw new Error('IP location service failed');\n         \n-        const ipData = await ipResponse.json();\n-        if (ipData.latitude && ipData.longitude) {\n-          location = { lat: ipData.latitude, lng: ipData.longitude };\n+        ipData = await ipResponse.json();\n+        if (ipData.loc) {\n+          const [lat, lng] = ipData.loc.split(',');\n+          location = { lat: parseFloat(lat), lng: parseFloat(lng) };\n           locationSource = 'ip';\n         } else {\n           throw new Error('Invalid IP location data');\n         }\n"
                },
                {
                    "date": 1736981640774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,8 +117,9 @@\n \n     // Get user's location\n     let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n     let locationSource = 'default';\n+    let ipData: any;\n     \n     try {\n       const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n         if (!navigator.geolocation) {\n"
                },
                {
                    "date": 1736981865809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,299 @@\n+'use client'\n+\n+import { EnvironmentalConditions, EnvironmentalCalculator } from './environmental-calculations'\n+\n+interface SubscriberCallback {\n+  (conditions: EnvironmentalConditions): void\n+}\n+\n+export class EnvironmentalService {\n+  private static instance: EnvironmentalService\n+  private conditions: EnvironmentalConditions\n+  private subscribers: Set<(conditions: EnvironmentalConditions) => void>\n+  private updateInterval: NodeJS.Timeout | null\n+  private baseAltitude: number // Base altitude that stays constant\n+  private lastUpdate: number // Last update timestamp\n+\n+  private constructor() {\n+    // Generate a stable random base altitude using a fixed seed\n+    this.baseAltitude = 100 + Math.floor(Math.random() * 1000)\n+    this.conditions = {\n+      temperature: 70, // °F\n+      humidity: 60,\n+      pressure: 1013.25,\n+      altitude: this.baseAltitude,\n+      windSpeed: 5,\n+      windDirection: 0,\n+      density: 1.225\n+    }\n+    this.subscribers = new Set()\n+    this.updateInterval = null\n+    this.lastUpdate = Date.now()\n+  }\n+\n+  public static getInstance(): EnvironmentalService {\n+    if (!EnvironmentalService.instance) {\n+      EnvironmentalService.instance = new EnvironmentalService()\n+    }\n+    return EnvironmentalService.instance\n+  }\n+\n+  public subscribe(callback: SubscriberCallback): () => void {\n+    this.subscribers.add(callback)\n+    callback(this.conditions)\n+    return () => {\n+      this.subscribers.delete(callback)\n+    }\n+  }\n+\n+  private notifySubscribers(): void {\n+    this.subscribers.forEach((callback) => callback(this.conditions))\n+  }\n+\n+  private async updateConditions(): Promise<void> {\n+    try {\n+      const conditions = await this.getCurrentConditions();\n+      this.conditions = {\n+        ...this.conditions,\n+        temperature: conditions.temperature,\n+        humidity: conditions.humidity,\n+        pressure: conditions.pressure,\n+        windSpeed: conditions.windSpeed,\n+        windDirection: conditions.windDirection,\n+        density: conditions.density\n+      };\n+      \n+      this.lastUpdate = Date.now();\n+      this.notifySubscribers();\n+    } catch (error) {\n+      console.error('Failed to update conditions:', error);\n+      // Keep using previous conditions if API fails\n+    }\n+  }\n+\n+  public startMonitoring(): void {\n+    if (!this.updateInterval) {\n+      this.updateInterval = setInterval(async () => {\n+        try {\n+          await this.updateConditions();\n+        } catch (error) {\n+          console.error('Error in monitoring interval:', error);\n+        }\n+      }, 1000 * 60 * 5); // Update every 5 minutes to avoid excessive API calls\n+      this.updateConditions(); // Initial update\n+    }\n+  }\n+\n+  public stopMonitoring(): void {\n+    if (this.updateInterval) {\n+      clearInterval(this.updateInterval)\n+      this.updateInterval = null\n+    }\n+  }\n+\n+  public getConditions(): EnvironmentalConditions {\n+    return { ...this.conditions }\n+  }\n+\n+  public calculateWindEffect(\n+    shotDirection: number\n+  ): { headwind: number; crosswind: number } {\n+    return EnvironmentalCalculator.calculateWindEffect(\n+      this.conditions.windSpeed,\n+      this.conditions.windDirection,\n+      shotDirection\n+    )\n+  }\n+\n+  public calculateAltitudeEffect(): number {\n+    return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n+  }\n+\n+  async getCurrentConditions(): Promise<EnvironmentalConditions> {\n+    const apiKey = process.env.NEXT_PUBLIC_TOMORROW_API_KEY;\n+    if (!apiKey) {\n+      throw new Error('Tomorrow.io API key not configured. Please set NEXT_PUBLIC_TOMORROW_API_KEY in .env');\n+    }\n+\n+    // Get user's location\n+    let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n+    let locationSource = 'default';\n+    let ipData: any;\n+    \n+    try {\n+      console.log('Attempting to get precise location via Geolocation API...');\n+      const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n+        if (!navigator.geolocation) {\n+          reject(new Error('Geolocation not supported'));\n+          return;\n+        }\n+        \n+        navigator.geolocation.getCurrentPosition(\n+          resolve,\n+          (error) => {\n+            // Handle different error cases\n+            switch (error.code) {\n+              case error.PERMISSION_DENIED:\n+                reject(new Error('User denied geolocation permission'));\n+                break;\n+              case error.POSITION_UNAVAILABLE:\n+                reject(new Error('Location information is unavailable'));\n+                break;\n+              case error.TIMEOUT:\n+                reject(new Error('The request to get user location timed out'));\n+                break;\n+              default:\n+                reject(new Error('An unknown error occurred'));\n+            }\n+          },\n+          {\n+            enableHighAccuracy: true,\n+            timeout: 10000, // Increased timeout to 10 seconds\n+            maximumAge: 300000 // Cache for 5 minutes\n+          }\n+        );\n+      });\n+      location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n+      locationSource = 'geolocation';\n+      console.log('Successfully got precise location:', location);\n+    } catch (error) {\n+      console.warn('Failed to get precise location:', error);\n+      \n+      // Try to get location from IP as fallback\n+      try {\n+        console.log('Attempting to get location from IP address...');\n+        // Try multiple IP geolocation services in case one fails\n+        const services = [\n+          {\n+            url: 'https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f',\n+            transform: (data: any) => ({\n+              lat: parseFloat(data.loc.split(',')[0]),\n+              lng: parseFloat(data.loc.split(',')[1]),\n+              city: data.city,\n+              region: data.region\n+            })\n+          },\n+          {\n+            url: 'https://ipapi.co/json',\n+            transform: (data: any) => ({\n+              lat: data.latitude,\n+              lng: data.longitude,\n+              city: data.city,\n+              region: data.region\n+            })\n+          }\n+        ];\n+\n+        for (const service of services) {\n+          try {\n+            const response = await fetch(service.url);\n+            if (!response.ok) continue;\n+            \n+            ipData = await response.json();\n+            const transformed = service.transform(ipData);\n+            \n+            if (transformed.lat && transformed.lng) {\n+              location = { lat: transformed.lat, lng: transformed.lng };\n+              locationSource = 'ip';\n+              console.log('Successfully got location from IP:', location);\n+              console.log('City:', transformed.city, 'Region:', transformed.region);\n+              break;\n+            }\n+          } catch (serviceError) {\n+            console.warn(`Failed to get location from ${service.url}:`, serviceError);\n+            continue;\n+          }\n+        }\n+\n+        if (locationSource === 'default') {\n+          throw new Error('All IP geolocation services failed');\n+        }\n+      } catch (ipError) {\n+        console.warn('Failed to get location from IP, using default:', ipError);\n+        locationSource = 'default';\n+      }\n+    }\n+    \n+    console.group('Location Detection');\n+    console.log(`Source: ${locationSource}`);\n+    console.log('Coordinates:', location);\n+    if (locationSource === 'ip' && ipData) {\n+      console.log('City:', ipData.city, 'Region:', ipData.region);\n+    }\n+    console.groupEnd();\n+    console.log('Fetching weather for coordinates:', location);\n+\n+    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&apikey=${apiKey}`;\n+\n+    // Cache weather data for 5 minutes to avoid excessive API calls\n+    const cacheKey = `weather-${location.lat}-${location.lng}`;\n+    const cachedData = localStorage.getItem(cacheKey);\n+    \n+    if (cachedData) {\n+      const { timestamp, data } = JSON.parse(cachedData);\n+      if (Date.now() - timestamp < 5 * 60 * 1000) {\n+        return this.transformWeatherData(data);\n+      }\n+    }\n+\n+    try {\n+      const response = await fetch(url);\n+      if (!response.ok) {\n+        throw new Error(`API request failed with status ${response.status}`);\n+      }\n+      \n+      const data = await response.json();\n+      const current = data?.data?.values;\n+      if (!current) {\n+        throw new Error('Invalid weather data received');\n+      }\n+\n+      // Cache the successful response\n+      localStorage.setItem(cacheKey, JSON.stringify({\n+        timestamp: Date.now(),\n+        data: current\n+      }));\n+\n+      console.log('Received weather data:', current);\n+      const transformed = this.transformWeatherData(current);\n+      console.log('Transformed weather data:', transformed);\n+      return transformed;\n+    } catch (error) {\n+      console.error('Failed to fetch weather data:', error);\n+      \n+      // If we have cached data, use it even if it's stale\n+      if (cachedData) {\n+        const { data } = JSON.parse(cachedData);\n+        console.warn('Using cached weather data due to API error');\n+        return this.transformWeatherData(data);\n+      }\n+      \n+      throw error;\n+    }\n+  }\n+\n+  private transformWeatherData(data: any): EnvironmentalConditions {\n+    const pressure = data.pressure || 1013.25; // Default to standard pressure if missing\n+    const temperature = data.temperature;\n+    const humidity = data.humidity;\n+    \n+    return {\n+      temperature: temperature,\n+      humidity: humidity,\n+      altitude: this.conditions.altitude,\n+      windSpeed: data.windSpeed,\n+      windDirection: data.windDirection,\n+      pressure: pressure,\n+      density: EnvironmentalCalculator.calculateAirDensity({\n+        temperature: temperature,\n+        humidity: humidity,\n+        pressure: pressure,\n+        altitude: this.conditions.altitude,\n+        windSpeed: data.windSpeed,\n+        windDirection: data.windDirection\n+      })\n+    };\n+  }\n+}\n+\n+export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736982518229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,267 +296,4 @@\n   }\n }\n \n export const environmentalService = EnvironmentalService.getInstance()\n-'use client'\n-\n-import { EnvironmentalConditions, EnvironmentalCalculator } from './environmental-calculations'\n-\n-interface SubscriberCallback {\n-  (conditions: EnvironmentalConditions): void\n-}\n-\n-export class EnvironmentalService {\n-  private static instance: EnvironmentalService\n-  private conditions: EnvironmentalConditions\n-  private subscribers: Set<(conditions: EnvironmentalConditions) => void>\n-  private updateInterval: NodeJS.Timeout | null\n-  private baseAltitude: number // Base altitude that stays constant\n-  private lastUpdate: number // Last update timestamp\n-\n-  private constructor() {\n-    // Generate a stable random base altitude using a fixed seed\n-    this.baseAltitude = 100 + Math.floor(Math.random() * 1000)\n-    this.conditions = {\n-      temperature: 70, // °F\n-      humidity: 60,\n-      pressure: 1013.25,\n-      altitude: this.baseAltitude,\n-      windSpeed: 5,\n-      windDirection: 0,\n-      density: 1.225\n-    }\n-    this.subscribers = new Set()\n-    this.updateInterval = null\n-    this.lastUpdate = Date.now()\n-  }\n-\n-  public static getInstance(): EnvironmentalService {\n-    if (!EnvironmentalService.instance) {\n-      EnvironmentalService.instance = new EnvironmentalService()\n-    }\n-    return EnvironmentalService.instance\n-  }\n-\n-  public subscribe(callback: SubscriberCallback): () => void {\n-    this.subscribers.add(callback)\n-    callback(this.conditions)\n-    return () => {\n-      this.subscribers.delete(callback)\n-    }\n-  }\n-\n-  private notifySubscribers(): void {\n-    this.subscribers.forEach((callback) => callback(this.conditions))\n-  }\n-\n-  private async updateConditions(): Promise<void> {\n-    try {\n-      const conditions = await this.getCurrentConditions();\n-      this.conditions = {\n-        ...this.conditions,\n-        temperature: conditions.temperature,\n-        humidity: conditions.humidity,\n-        pressure: conditions.pressure,\n-        windSpeed: conditions.windSpeed,\n-        windDirection: conditions.windDirection,\n-        density: conditions.density\n-      };\n-      \n-      this.lastUpdate = Date.now();\n-      this.notifySubscribers();\n-    } catch (error) {\n-      console.error('Failed to update conditions:', error);\n-      // Keep using previous conditions if API fails\n-    }\n-  }\n-\n-  public startMonitoring(): void {\n-    if (!this.updateInterval) {\n-      this.updateInterval = setInterval(async () => {\n-        try {\n-          await this.updateConditions();\n-        } catch (error) {\n-          console.error('Error in monitoring interval:', error);\n-        }\n-      }, 1000 * 60 * 5); // Update every 5 minutes to avoid excessive API calls\n-      this.updateConditions(); // Initial update\n-    }\n-  }\n-\n-  public stopMonitoring(): void {\n-    if (this.updateInterval) {\n-      clearInterval(this.updateInterval)\n-      this.updateInterval = null\n-    }\n-  }\n-\n-  public getConditions(): EnvironmentalConditions {\n-    return { ...this.conditions }\n-  }\n-\n-  public calculateWindEffect(\n-    shotDirection: number\n-  ): { headwind: number; crosswind: number } {\n-    return EnvironmentalCalculator.calculateWindEffect(\n-      this.conditions.windSpeed,\n-      this.conditions.windDirection,\n-      shotDirection\n-    )\n-  }\n-\n-  public calculateAltitudeEffect(): number {\n-    return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n-  }\n-\n-  async getCurrentConditions(): Promise<EnvironmentalConditions> {\n-    const apiKey = process.env.NEXT_PUBLIC_TOMORROW_API_KEY;\n-    if (!apiKey) {\n-      throw new Error('Tomorrow.io API key not configured. Please set NEXT_PUBLIC_TOMORROW_API_KEY in .env');\n-    }\n-\n-    // Get user's location\n-    let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n-    let locationSource = 'default';\n-    let ipData: any;\n-    \n-    try {\n-      const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n-        if (!navigator.geolocation) {\n-          reject(new Error('Geolocation not supported'));\n-          return;\n-        }\n-        \n-        navigator.geolocation.getCurrentPosition(\n-          resolve,\n-          (error) => {\n-            // Handle different error cases\n-            switch (error.code) {\n-              case error.PERMISSION_DENIED:\n-                reject(new Error('User denied geolocation permission'));\n-                break;\n-              case error.POSITION_UNAVAILABLE:\n-                reject(new Error('Location information is unavailable'));\n-                break;\n-              case error.TIMEOUT:\n-                reject(new Error('The request to get user location timed out'));\n-                break;\n-              default:\n-                reject(new Error('An unknown error occurred'));\n-            }\n-          },\n-          {\n-            enableHighAccuracy: true,\n-            timeout: 2000, // Faster timeout\n-            maximumAge: 0\n-          }\n-        );\n-      });\n-      location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n-      locationSource = 'geolocation';\n-    } catch (error) {\n-      console.warn('Failed to get precise location:', error);\n-      \n-      // Try to get location from IP as fallback\n-      let ipData: any;\n-      try {\n-        // Try a more reliable IP geolocation service\n-        const ipResponse = await fetch('https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f');\n-        if (!ipResponse.ok) throw new Error('IP location service failed');\n-        \n-        ipData = await ipResponse.json();\n-        if (ipData.loc) {\n-          const [lat, lng] = ipData.loc.split(',');\n-          location = { lat: parseFloat(lat), lng: parseFloat(lng) };\n-          locationSource = 'ip';\n-        } else {\n-          throw new Error('Invalid IP location data');\n-        }\n-      } catch (ipError) {\n-        console.warn('Failed to get approximate location:', ipError);\n-        locationSource = 'default';\n-      }\n-    }\n-    \n-    console.group('Location Detection');\n-    console.log(`Source: ${locationSource}`);\n-    console.log('Coordinates:', location);\n-    if (locationSource === 'ip') {\n-      console.log('City:', ipData.city, 'Region:', ipData.region);\n-    }\n-    console.groupEnd();\n-    console.log('Fetching weather for coordinates:', location);\n-\n-    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&apikey=${apiKey}`;\n-\n-    // Cache weather data for 5 minutes to avoid excessive API calls\n-    const cacheKey = `weather-${location.lat}-${location.lng}`;\n-    const cachedData = localStorage.getItem(cacheKey);\n-    \n-    if (cachedData) {\n-      const { timestamp, data } = JSON.parse(cachedData);\n-      if (Date.now() - timestamp < 5 * 60 * 1000) {\n-        return this.transformWeatherData(data);\n-      }\n-    }\n-\n-    try {\n-      const response = await fetch(url);\n-      if (!response.ok) {\n-        throw new Error(`API request failed with status ${response.status}`);\n-      }\n-      \n-      const data = await response.json();\n-      const current = data?.data?.values;\n-      if (!current) {\n-        throw new Error('Invalid weather data received');\n-      }\n-\n-      // Cache the successful response\n-      localStorage.setItem(cacheKey, JSON.stringify({\n-        timestamp: Date.now(),\n-        data: current\n-      }));\n-\n-      console.log('Received weather data:', current);\n-      const transformed = this.transformWeatherData(current);\n-      console.log('Transformed weather data:', transformed);\n-      return transformed;\n-    } catch (error) {\n-      console.error('Failed to fetch weather data:', error);\n-      \n-      // If we have cached data, use it even if it's stale\n-      if (cachedData) {\n-        const { data } = JSON.parse(cachedData);\n-        console.warn('Using cached weather data due to API error');\n-        return this.transformWeatherData(data);\n-      }\n-      \n-      throw error;\n-    }\n-  }\n-\n-  private transformWeatherData(data: any): EnvironmentalConditions {\n-    const pressure = data.pressure || 1013.25; // Default to standard pressure if missing\n-    const temperature = data.temperature;\n-    const humidity = data.humidity;\n-    \n-    return {\n-      temperature: temperature,\n-      humidity: humidity,\n-      altitude: this.conditions.altitude,\n-      windSpeed: data.windSpeed,\n-      windDirection: data.windDirection,\n-      pressure: pressure,\n-      density: EnvironmentalCalculator.calculateAirDensity({\n-        temperature: temperature,\n-        humidity: humidity,\n-        pressure: pressure,\n-        altitude: this.conditions.altitude,\n-        windSpeed: data.windSpeed,\n-        windDirection: data.windDirection\n-      })\n-    };\n-  }\n-}\n-\n-export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736982594863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,100 +118,169 @@\n     // Get user's location\n     let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n     let locationSource = 'default';\n     let ipData: any;\n-    \n+\n+    // Try to get cached location first\n     try {\n-      console.log('Attempting to get precise location via Geolocation API...');\n-      const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n-        if (!navigator.geolocation) {\n-          reject(new Error('Geolocation not supported'));\n-          return;\n+      const cachedLocation = localStorage.getItem('user-location');\n+      if (cachedLocation) {\n+        const { timestamp, data, source } = JSON.parse(cachedLocation);\n+        // Use cache if less than 30 minutes old\n+        if (Date.now() - timestamp < 30 * 60 * 1000) {\n+          location = data;\n+          locationSource = source;\n+          console.log('Using cached location:', location);\n+          console.log('Cache age:', Math.round((Date.now() - timestamp) / 1000 / 60), 'minutes');\n         }\n-        \n-        navigator.geolocation.getCurrentPosition(\n-          resolve,\n-          (error) => {\n-            // Handle different error cases\n-            switch (error.code) {\n-              case error.PERMISSION_DENIED:\n-                reject(new Error('User denied geolocation permission'));\n-                break;\n-              case error.POSITION_UNAVAILABLE:\n-                reject(new Error('Location information is unavailable'));\n-                break;\n-              case error.TIMEOUT:\n-                reject(new Error('The request to get user location timed out'));\n-                break;\n-              default:\n-                reject(new Error('An unknown error occurred'));\n-            }\n-          },\n-          {\n-            enableHighAccuracy: true,\n-            timeout: 10000, // Increased timeout to 10 seconds\n-            maximumAge: 300000 // Cache for 5 minutes\n-          }\n-        );\n-      });\n-      location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n-      locationSource = 'geolocation';\n-      console.log('Successfully got precise location:', location);\n+      }\n     } catch (error) {\n-      console.warn('Failed to get precise location:', error);\n-      \n-      // Try to get location from IP as fallback\n+      console.warn('Failed to read cached location:', error);\n+    }\n+\n+    // Only try to get new location if we don't have a recent cached one\n+    if (locationSource === 'default') {\n       try {\n-        console.log('Attempting to get location from IP address...');\n-        // Try multiple IP geolocation services in case one fails\n-        const services = [\n-          {\n-            url: 'https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f',\n-            transform: (data: any) => ({\n-              lat: parseFloat(data.loc.split(',')[0]),\n-              lng: parseFloat(data.loc.split(',')[1]),\n-              city: data.city,\n-              region: data.region\n-            })\n-          },\n-          {\n-            url: 'https://ipapi.co/json',\n-            transform: (data: any) => ({\n-              lat: data.latitude,\n-              lng: data.longitude,\n-              city: data.city,\n-              region: data.region\n-            })\n+        console.log('Attempting to get precise location via Geolocation API...');\n+        const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n+          if (!navigator.geolocation) {\n+            reject(new Error('Geolocation not supported'));\n+            return;\n           }\n-        ];\n+          \n+          // First try with high accuracy\n+          navigator.geolocation.getCurrentPosition(\n+            (position) => {\n+              console.log('Got high accuracy position:', position);\n+              resolve(position);\n+            },\n+            (error) => {\n+              console.warn('High accuracy position failed:', error);\n+              // If high accuracy fails, try with lower accuracy\n+              navigator.geolocation.getCurrentPosition(\n+                resolve,\n+                reject,\n+                {\n+                  enableHighAccuracy: false,\n+                  timeout: 10000,\n+                  maximumAge: 300000\n+                }\n+              );\n+            },\n+            {\n+              enableHighAccuracy: true,\n+              timeout: 10000,\n+              maximumAge: 300000\n+            }\n+          );\n+        });\n \n-        for (const service of services) {\n-          try {\n-            const response = await fetch(service.url);\n-            if (!response.ok) continue;\n-            \n-            ipData = await response.json();\n-            const transformed = service.transform(ipData);\n-            \n-            if (transformed.lat && transformed.lng) {\n-              location = { lat: transformed.lat, lng: transformed.lng };\n-              locationSource = 'ip';\n-              console.log('Successfully got location from IP:', location);\n-              console.log('City:', transformed.city, 'Region:', transformed.region);\n-              break;\n+        // Validate coordinates are reasonable\n+        if (pos.coords.latitude >= -90 && pos.coords.latitude <= 90 &&\n+            pos.coords.longitude >= -180 && pos.coords.longitude <= 180 &&\n+            pos.coords.accuracy < 10000) { // Accuracy better than 10km\n+          location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n+          locationSource = 'geolocation';\n+          console.log('Successfully got precise location:', location);\n+          console.log('Accuracy:', pos.coords.accuracy, 'meters');\n+          \n+          // Cache the successful location\n+          localStorage.setItem('user-location', JSON.stringify({\n+            timestamp: Date.now(),\n+            data: location,\n+            source: locationSource,\n+            accuracy: pos.coords.accuracy\n+          }));\n+        } else {\n+          throw new Error(`Invalid or inaccurate coordinates: ${JSON.stringify(pos.coords)}`);\n+        }\n+      } catch (error) {\n+        console.warn('Failed to get precise location:', error);\n+        \n+        // Try to get location from IP as fallback\n+        try {\n+          console.log('Attempting to get location from IP address...');\n+          // Try multiple IP geolocation services in case one fails\n+          const services = [\n+            {\n+              url: 'https://api.bigdatacloud.net/data/reverse-geocode-client',\n+              transform: (data: any) => ({\n+                lat: data.latitude,\n+                lng: data.longitude,\n+                city: data.city,\n+                region: data.principalSubdivision,\n+                accuracy: data.accuracyRadius\n+              })\n+            },\n+            {\n+              url: 'https://ipapi.co/json',\n+              transform: (data: any) => ({\n+                lat: data.latitude,\n+                lng: data.longitude,\n+                city: data.city,\n+                region: data.region,\n+                accuracy: 25000 // Typical IP geolocation accuracy in meters\n+              })\n+            },\n+            {\n+              url: 'https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f',\n+              transform: (data: any) => ({\n+                lat: parseFloat(data.loc.split(',')[0]),\n+                lng: parseFloat(data.loc.split(',')[1]),\n+                city: data.city,\n+                region: data.region,\n+                accuracy: 25000\n+              })\n             }\n-          } catch (serviceError) {\n-            console.warn(`Failed to get location from ${service.url}:`, serviceError);\n-            continue;\n+          ];\n+\n+          let bestLocation = null;\n+          let bestAccuracy = Infinity;\n+\n+          for (const service of services) {\n+            try {\n+              console.log(`Trying ${service.url}...`);\n+              const response = await fetch(service.url);\n+              if (!response.ok) {\n+                console.warn(`Service ${service.url} returned ${response.status}`);\n+                continue;\n+              }\n+              \n+              ipData = await response.json();\n+              console.log(`Response from ${service.url}:`, ipData);\n+              \n+              const transformed = service.transform(ipData);\n+              \n+              // Validate coordinates\n+              if (transformed.lat >= -90 && transformed.lat <= 90 &&\n+                  transformed.lng >= -180 && transformed.lng <= 180) {\n+                // Keep track of the most accurate result\n+                if (transformed.accuracy < bestAccuracy) {\n+                  bestLocation = transformed;\n+                  bestAccuracy = transformed.accuracy;\n+                }\n+              } else {\n+                console.warn(`Invalid coordinates from ${service.url}:`, transformed);\n+              }\n+            } catch (serviceError) {\n+              console.warn(`Failed to get location from ${service.url}:`, serviceError);\n+              continue;\n+            }\n           }\n-        }\n \n-        if (locationSource === 'default') {\n-          throw new Error('All IP geolocation services failed');\n+          if (bestLocation) {\n+            location = { lat: bestLocation.lat, lng: bestLocation.lng };\n+            locationSource = 'ip';\n+            console.log('Using most accurate IP location:', location);\n+            console.log('Accuracy:', bestAccuracy, 'meters');\n+            console.log('City:', bestLocation.city, 'Region:', bestLocation.region);\n+          } else {\n+            throw new Error('No valid location from any IP service');\n+          }\n+        } catch (ipError) {\n+          console.warn('Failed to get location from IP, using default:', ipError);\n+          locationSource = 'default';\n         }\n-      } catch (ipError) {\n-        console.warn('Failed to get location from IP, using default:', ipError);\n-        locationSource = 'default';\n       }\n     }\n     \n     console.group('Location Detection');\n"
                },
                {
                    "date": 1736987130501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,8 +182,25 @@\n           locationSource = 'geolocation';\n           console.log('Successfully got precise location:', location);\n           console.log('Accuracy:', pos.coords.accuracy, 'meters');\n           \n+          // Get city name for GPS coordinates\n+          try {\n+            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode?latitude=${location.lat}&longitude=${location.lng}&localityLanguage=en&key=bdc_1234567890`);\n+            if (response.ok) {\n+              const geocodeData = await response.json();\n+              console.log('Location details:', {\n+                city: geocodeData.city,\n+                locality: geocodeData.locality,\n+                county: geocodeData.localityInfo?.administrative?.[2]?.name,\n+                state: geocodeData.principalSubdivision,\n+                country: geocodeData.countryName\n+              });\n+            }\n+          } catch (geocodeError) {\n+            console.warn('Failed to get city name:', geocodeError);\n+          }\n+          \n           // Cache the successful location\n           localStorage.setItem('user-location', JSON.stringify({\n             timestamp: Date.now(),\n             data: location,\n"
                },
                {
                    "date": 1736987264468,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -308,78 +308,155 @@\n     }\n     console.groupEnd();\n     console.log('Fetching weather for coordinates:', location);\n \n-    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&apikey=${apiKey}`;\n+    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&units=imperial&apikey=${apiKey}`;\n \n     // Cache weather data for 5 minutes to avoid excessive API calls\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n     const cachedData = localStorage.getItem(cacheKey);\n     \n     if (cachedData) {\n       const { timestamp, data } = JSON.parse(cachedData);\n       if (Date.now() - timestamp < 5 * 60 * 1000) {\n+        console.log('Using cached weather data:', data);\n         return this.transformWeatherData(data);\n       }\n     }\n \n     try {\n+      console.log('Fetching fresh weather data from Tomorrow.io...');\n       const response = await fetch(url);\n       if (!response.ok) {\n         throw new Error(`API request failed with status ${response.status}`);\n       }\n       \n       const data = await response.json();\n-      const current = data?.data?.values;\n-      if (!current) {\n+      console.log('Raw weather response:', data);\n+      \n+      const values = data?.data?.values;\n+      if (!values) {\n         throw new Error('Invalid weather data received');\n       }\n \n+      // Validate weather data\n+      if (typeof values.temperature !== 'number' || \n+          values.temperature < -100 || \n+          values.temperature > 150) {\n+        throw new Error(`Invalid temperature value: ${values.temperature}°F`);\n+      }\n+\n+      if (typeof values.humidity !== 'number' || \n+          values.humidity < 0 || \n+          values.humidity > 100) {\n+        throw new Error(`Invalid humidity value: ${values.humidity}%`);\n+      }\n+\n+      if (typeof values.pressure !== 'number' || \n+          values.pressure < 800 || \n+          values.pressure > 1200) {\n+        throw new Error(`Invalid pressure value: ${values.pressure} mb`);\n+      }\n+\n       // Cache the successful response\n       localStorage.setItem(cacheKey, JSON.stringify({\n         timestamp: Date.now(),\n-        data: current\n+        data: values\n       }));\n \n-      console.log('Received weather data:', current);\n-      const transformed = this.transformWeatherData(current);\n+      console.group('Weather Data');\n+      console.log('Temperature:', values.temperature, '°F');\n+      console.log('Humidity:', values.humidity, '%');\n+      console.log('Pressure:', values.pressure, 'mb');\n+      console.log('Wind Speed:', values.windSpeed, 'mph');\n+      console.log('Wind Direction:', values.windDirection, '°');\n+      console.groupEnd();\n+\n+      const transformed = this.transformWeatherData(values);\n       console.log('Transformed weather data:', transformed);\n       return transformed;\n     } catch (error) {\n       console.error('Failed to fetch weather data:', error);\n       \n       // If we have cached data, use it even if it's stale\n       if (cachedData) {\n         const { data } = JSON.parse(cachedData);\n-        console.warn('Using cached weather data due to API error');\n+        console.warn('Using stale cached weather data due to API error');\n         return this.transformWeatherData(data);\n       }\n       \n-      throw error;\n+      // If all else fails, return reasonable defaults for Jacksonville, FL\n+      console.warn('Using default weather data');\n+      return {\n+        temperature: 75, // °F\n+        humidity: 70, // %\n+        pressure: 1013.25, // mb (standard sea level pressure)\n+        altitude: 10, // ft (Jacksonville is near sea level)\n+        windSpeed: 8, // mph (typical coastal breeze)\n+        windDirection: 90, // ° (typical easterly wind from Atlantic)\n+        density: this.calculateAirDensity({\n+          temperature: 75,\n+          humidity: 70,\n+          pressure: 1013.25,\n+          altitude: 10,\n+          windSpeed: 8,\n+          windDirection: 90\n+        })\n+      };\n     }\n   }\n \n+  private calculateAirDensity(conditions: EnvironmentalConditions): number {\n+    // Convert units for density calculation\n+    const tempC = (conditions.temperature - 32) * 5/9; // °F to °C\n+    const pressurePA = conditions.pressure * 100; // mb to Pa\n+    \n+    // Calculate saturation vapor pressure using Magnus formula\n+    const a = 6.1121; // mb\n+    const b = 17.368;\n+    const c = 238.88; // °C\n+    const svp = a * Math.exp((b * tempC) / (c + tempC));\n+    \n+    // Calculate actual vapor pressure\n+    const vp = svp * (conditions.humidity / 100);\n+    \n+    // Gas constants\n+    const Rd = 287.058; // J/(kg·K) - Specific gas constant for dry air\n+    const Rv = 461.495; // J/(kg·K) - Specific gas constant for water vapor\n+    \n+    // Convert temperature to Kelvin\n+    const tempK = tempC + 273.15;\n+    \n+    // Calculate air density using the enhanced equation that accounts for humidity\n+    const density = (pressurePA - (vp * 100)) / (Rd * tempK) + (vp * 100) / (Rv * tempK);\n+    \n+    return Math.round(density * 1000) / 1000; // Round to 3 decimal places\n+  }\n+\n   private transformWeatherData(data: any): EnvironmentalConditions {\n-    const pressure = data.pressure || 1013.25; // Default to standard pressure if missing\n-    const temperature = data.temperature;\n-    const humidity = data.humidity;\n+    // Ensure we're working with numbers\n+    const temperature = Number(data.temperature);\n+    const humidity = Number(data.humidity);\n+    const pressure = Number(data.pressure);\n+    const windSpeed = Number(data.windSpeed);\n+    const windDirection = Number(data.windDirection);\n     \n-    return {\n-      temperature: temperature,\n-      humidity: humidity,\n-      altitude: this.conditions.altitude,\n-      windSpeed: data.windSpeed,\n-      windDirection: data.windDirection,\n-      pressure: pressure,\n-      density: EnvironmentalCalculator.calculateAirDensity({\n-        temperature: temperature,\n-        humidity: humidity,\n-        pressure: pressure,\n-        altitude: this.conditions.altitude,\n-        windSpeed: data.windSpeed,\n-        windDirection: data.windDirection\n-      })\n+    // Get altitude from geolocation or default to sea level for Jacksonville\n+    const altitude = 10; // Jacksonville is near sea level\n+    \n+    const conditions = {\n+      temperature,\n+      humidity,\n+      pressure,\n+      altitude,\n+      windSpeed,\n+      windDirection,\n+      density: 0 // Will be calculated below\n     };\n+    \n+    conditions.density = this.calculateAirDensity(conditions);\n+    \n+    return conditions;\n   }\n }\n \n export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736987274997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,470 @@\n+'use client'\n+\n+import { EnvironmentalConditions, EnvironmentalCalculator } from './environmental-calculations'\n+\n+interface SubscriberCallback {\n+  (conditions: EnvironmentalConditions): void\n+}\n+\n+export class EnvironmentalService {\n+  private static instance: EnvironmentalService\n+  private conditions: EnvironmentalConditions\n+  private subscribers: Set<(conditions: EnvironmentalConditions) => void>\n+  private updateInterval: NodeJS.Timeout | null\n+  private baseAltitude: number // Base altitude that stays constant\n+  private lastUpdate: number // Last update timestamp\n+\n+  private constructor() {\n+    // Generate a stable random base altitude using a fixed seed\n+    this.baseAltitude = 100 + Math.floor(Math.random() * 1000)\n+    this.conditions = {\n+      temperature: 70, // °F\n+      humidity: 60,\n+      pressure: 1013.25,\n+      altitude: this.baseAltitude,\n+      windSpeed: 5,\n+      windDirection: 0,\n+      density: 1.225\n+    }\n+    this.subscribers = new Set()\n+    this.updateInterval = null\n+    this.lastUpdate = Date.now()\n+  }\n+\n+  public static getInstance(): EnvironmentalService {\n+    if (!EnvironmentalService.instance) {\n+      EnvironmentalService.instance = new EnvironmentalService()\n+    }\n+    return EnvironmentalService.instance\n+  }\n+\n+  public subscribe(callback: SubscriberCallback): () => void {\n+    this.subscribers.add(callback)\n+    callback(this.conditions)\n+    return () => {\n+      this.subscribers.delete(callback)\n+    }\n+  }\n+\n+  private notifySubscribers(): void {\n+    this.subscribers.forEach((callback) => callback(this.conditions))\n+  }\n+\n+  private async updateConditions(): Promise<void> {\n+    try {\n+      const conditions = await this.getCurrentConditions();\n+      this.conditions = {\n+        ...this.conditions,\n+        temperature: conditions.temperature,\n+        humidity: conditions.humidity,\n+        pressure: conditions.pressure,\n+        windSpeed: conditions.windSpeed,\n+        windDirection: conditions.windDirection,\n+        density: conditions.density\n+      };\n+      \n+      this.lastUpdate = Date.now();\n+      this.notifySubscribers();\n+    } catch (error) {\n+      console.error('Failed to update conditions:', error);\n+      // Keep using previous conditions if API fails\n+    }\n+  }\n+\n+  public startMonitoring(): void {\n+    if (!this.updateInterval) {\n+      this.updateInterval = setInterval(async () => {\n+        try {\n+          await this.updateConditions();\n+        } catch (error) {\n+          console.error('Error in monitoring interval:', error);\n+        }\n+      }, 1000 * 60 * 5); // Update every 5 minutes to avoid excessive API calls\n+      this.updateConditions(); // Initial update\n+    }\n+  }\n+\n+  public stopMonitoring(): void {\n+    if (this.updateInterval) {\n+      clearInterval(this.updateInterval)\n+      this.updateInterval = null\n+    }\n+  }\n+\n+  public getConditions(): EnvironmentalConditions {\n+    return { ...this.conditions }\n+  }\n+\n+  public calculateWindEffect(\n+    shotDirection: number\n+  ): { headwind: number; crosswind: number } {\n+    return EnvironmentalCalculator.calculateWindEffect(\n+      this.conditions.windSpeed,\n+      this.conditions.windDirection,\n+      shotDirection\n+    )\n+  }\n+\n+  public calculateAltitudeEffect(): number {\n+    return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n+  }\n+\n+  async getCurrentConditions(): Promise<EnvironmentalConditions> {\n+    const apiKey = process.env.NEXT_PUBLIC_TOMORROW_API_KEY;\n+    if (!apiKey) {\n+      throw new Error('Tomorrow.io API key not configured. Please set NEXT_PUBLIC_TOMORROW_API_KEY in .env');\n+    }\n+\n+    // Get user's location\n+    let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n+    let locationSource = 'default';\n+    let ipData: any;\n+\n+    // Try to get cached location first\n+    try {\n+      const cachedLocation = localStorage.getItem('user-location');\n+      if (cachedLocation) {\n+        const { timestamp, data, source } = JSON.parse(cachedLocation);\n+        // Use cache if less than 30 minutes old\n+        if (Date.now() - timestamp < 30 * 60 * 1000) {\n+          location = data;\n+          locationSource = source;\n+          console.log('Using cached location:', location);\n+          console.log('Cache age:', Math.round((Date.now() - timestamp) / 1000 / 60), 'minutes');\n+        }\n+      }\n+    } catch (error) {\n+      console.warn('Failed to read cached location:', error);\n+    }\n+\n+    // Only try to get new location if we don't have a recent cached one\n+    if (locationSource === 'default') {\n+      try {\n+        console.log('Attempting to get precise location via Geolocation API...');\n+        const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n+          if (!navigator.geolocation) {\n+            reject(new Error('Geolocation not supported'));\n+            return;\n+          }\n+          \n+          // First try with high accuracy\n+          navigator.geolocation.getCurrentPosition(\n+            (position) => {\n+              console.log('Got high accuracy position:', position);\n+              resolve(position);\n+            },\n+            (error) => {\n+              console.warn('High accuracy position failed:', error);\n+              // If high accuracy fails, try with lower accuracy\n+              navigator.geolocation.getCurrentPosition(\n+                resolve,\n+                reject,\n+                {\n+                  enableHighAccuracy: false,\n+                  timeout: 10000,\n+                  maximumAge: 300000\n+                }\n+              );\n+            },\n+            {\n+              enableHighAccuracy: true,\n+              timeout: 10000,\n+              maximumAge: 300000\n+            }\n+          );\n+        });\n+\n+        // Validate coordinates are reasonable\n+        if (pos.coords.latitude >= -90 && pos.coords.latitude <= 90 &&\n+            pos.coords.longitude >= -180 && pos.coords.longitude <= 180 &&\n+            pos.coords.accuracy < 10000) { // Accuracy better than 10km\n+          location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n+          locationSource = 'geolocation';\n+          console.log('Successfully got precise location:', location);\n+          console.log('Accuracy:', pos.coords.accuracy, 'meters');\n+          \n+          // Get city name for GPS coordinates\n+          try {\n+            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode?latitude=${location.lat}&longitude=${location.lng}&localityLanguage=en&key=bdc_1234567890`);\n+            if (response.ok) {\n+              const geocodeData = await response.json();\n+              console.log('Location details:', {\n+                city: geocodeData.city,\n+                locality: geocodeData.locality,\n+                county: geocodeData.localityInfo?.administrative?.[2]?.name,\n+                state: geocodeData.principalSubdivision,\n+                country: geocodeData.countryName\n+              });\n+            }\n+          } catch (geocodeError) {\n+            console.warn('Failed to get city name:', geocodeError);\n+          }\n+          \n+          // Cache the successful location\n+          localStorage.setItem('user-location', JSON.stringify({\n+            timestamp: Date.now(),\n+            data: location,\n+            source: locationSource,\n+            accuracy: pos.coords.accuracy\n+          }));\n+        } else {\n+          throw new Error(`Invalid or inaccurate coordinates: ${JSON.stringify(pos.coords)}`);\n+        }\n+      } catch (error) {\n+        console.warn('Failed to get precise location:', error);\n+        \n+        // Try to get location from IP as fallback\n+        try {\n+          console.log('Attempting to get location from IP address...');\n+          // Try multiple IP geolocation services in case one fails\n+          const services = [\n+            {\n+              url: 'https://api.bigdatacloud.net/data/reverse-geocode-client',\n+              transform: (data: any) => ({\n+                lat: data.latitude,\n+                lng: data.longitude,\n+                city: data.city,\n+                region: data.principalSubdivision,\n+                accuracy: data.accuracyRadius\n+              })\n+            },\n+            {\n+              url: 'https://ipapi.co/json',\n+              transform: (data: any) => ({\n+                lat: data.latitude,\n+                lng: data.longitude,\n+                city: data.city,\n+                region: data.region,\n+                accuracy: 25000 // Typical IP geolocation accuracy in meters\n+              })\n+            },\n+            {\n+              url: 'https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f',\n+              transform: (data: any) => ({\n+                lat: parseFloat(data.loc.split(',')[0]),\n+                lng: parseFloat(data.loc.split(',')[1]),\n+                city: data.city,\n+                region: data.region,\n+                accuracy: 25000\n+              })\n+            }\n+          ];\n+\n+          let bestLocation = null;\n+          let bestAccuracy = Infinity;\n+\n+          for (const service of services) {\n+            try {\n+              console.log(`Trying ${service.url}...`);\n+              const response = await fetch(service.url);\n+              if (!response.ok) {\n+                console.warn(`Service ${service.url} returned ${response.status}`);\n+                continue;\n+              }\n+              \n+              ipData = await response.json();\n+              console.log(`Response from ${service.url}:`, ipData);\n+              \n+              const transformed = service.transform(ipData);\n+              \n+              // Validate coordinates\n+              if (transformed.lat >= -90 && transformed.lat <= 90 &&\n+                  transformed.lng >= -180 && transformed.lng <= 180) {\n+                // Keep track of the most accurate result\n+                if (transformed.accuracy < bestAccuracy) {\n+                  bestLocation = transformed;\n+                  bestAccuracy = transformed.accuracy;\n+                }\n+              } else {\n+                console.warn(`Invalid coordinates from ${service.url}:`, transformed);\n+              }\n+            } catch (serviceError) {\n+              console.warn(`Failed to get location from ${service.url}:`, serviceError);\n+              continue;\n+            }\n+          }\n+\n+          if (bestLocation) {\n+            location = { lat: bestLocation.lat, lng: bestLocation.lng };\n+            locationSource = 'ip';\n+            console.log('Using most accurate IP location:', location);\n+            console.log('Accuracy:', bestAccuracy, 'meters');\n+            console.log('City:', bestLocation.city, 'Region:', bestLocation.region);\n+          } else {\n+            throw new Error('No valid location from any IP service');\n+          }\n+        } catch (ipError) {\n+          console.warn('Failed to get location from IP, using default:', ipError);\n+          locationSource = 'default';\n+        }\n+      }\n+    }\n+    \n+    console.group('Location Detection');\n+    console.log(`Source: ${locationSource}`);\n+    console.log('Coordinates:', location);\n+    if (locationSource === 'ip' && ipData) {\n+      console.log('City:', ipData.city, 'Region:', ipData.region);\n+    }\n+    console.groupEnd();\n+    console.log('Fetching weather for coordinates:', location);\n+\n+    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&units=imperial&apikey=${apiKey}`;\n+\n+    // Cache weather data for 5 minutes to avoid excessive API calls\n+    const cacheKey = `weather-${location.lat}-${location.lng}`;\n+    const cachedData = localStorage.getItem(cacheKey);\n+    \n+    if (cachedData) {\n+      const { timestamp, data } = JSON.parse(cachedData);\n+      if (Date.now() - timestamp < 5 * 60 * 1000) {\n+        console.log('Using cached weather data:', data);\n+        return this.transformWeatherData(data);\n+      }\n+    }\n+\n+    try {\n+      console.log('Fetching fresh weather data from Tomorrow.io...');\n+      const response = await fetch(url);\n+      if (!response.ok) {\n+        throw new Error(`API request failed with status ${response.status}`);\n+      }\n+      \n+      const data = await response.json();\n+      console.log('Raw weather response:', data);\n+      \n+      const values = data?.data?.values;\n+      if (!values) {\n+        throw new Error('Invalid weather data received');\n+      }\n+\n+      // Validate weather data\n+      if (typeof values.temperature !== 'number' || \n+          values.temperature < -100 || \n+          values.temperature > 150) {\n+        throw new Error(`Invalid temperature value: ${values.temperature}°F`);\n+      }\n+\n+      if (typeof values.humidity !== 'number' || \n+          values.humidity < 0 || \n+          values.humidity > 100) {\n+        throw new Error(`Invalid humidity value: ${values.humidity}%`);\n+      }\n+\n+      if (typeof values.pressure !== 'number' || \n+          values.pressure < 800 || \n+          values.pressure > 1200) {\n+        throw new Error(`Invalid pressure value: ${values.pressure} mb`);\n+      }\n+\n+      // Cache the successful response\n+      localStorage.setItem(cacheKey, JSON.stringify({\n+        timestamp: Date.now(),\n+        data: values\n+      }));\n+\n+      console.group('Weather Data');\n+      console.log('Temperature:', values.temperature, '°F');\n+      console.log('Humidity:', values.humidity, '%');\n+      console.log('Pressure:', values.pressure, 'mb');\n+      console.log('Wind Speed:', values.windSpeed, 'mph');\n+      console.log('Wind Direction:', values.windDirection, '°');\n+      console.groupEnd();\n+\n+      const transformed = this.transformWeatherData(values);\n+      console.log('Transformed weather data:', transformed);\n+      return transformed;\n+    } catch (error) {\n+      console.error('Failed to fetch weather data:', error);\n+      \n+      // If we have cached data, use it even if it's stale\n+      if (cachedData) {\n+        const { data } = JSON.parse(cachedData);\n+        console.warn('Using stale cached weather data due to API error');\n+        return this.transformWeatherData(data);\n+      }\n+      \n+      // If all else fails, return reasonable defaults for Jacksonville, FL\n+      console.warn('Using default weather data');\n+      return {\n+        temperature: 75, // °F\n+        humidity: 70, // %\n+        pressure: 1013.25, // mb (standard sea level pressure)\n+        altitude: 10, // ft (Jacksonville is near sea level)\n+        windSpeed: 8, // mph (typical coastal breeze)\n+        windDirection: 90, // ° (typical easterly wind from Atlantic)\n+        density: this.calculateAirDensity({\n+          temperature: 75,\n+          humidity: 70,\n+          pressure: 1013.25,\n+          altitude: 10,\n+          windSpeed: 8,\n+          windDirection: 90\n+        })\n+      };\n+    }\n+  }\n+\n+  private calculateAirDensity(conditions: EnvironmentalConditions): number {\n+    // Convert units for density calculation\n+    const tempC = (conditions.temperature - 32) * 5/9; // °F to °C\n+    const pressurePA = conditions.pressure * 100; // mb to Pa\n+    \n+    // Calculate saturation vapor pressure using Magnus formula\n+    const a = 6.1121; // mb\n+    const b = 17.368;\n+    const c = 238.88; // °C\n+    const svp = a * Math.exp((b * tempC) / (c + tempC));\n+    \n+    // Calculate actual vapor pressure\n+    const vp = svp * (conditions.humidity / 100);\n+    \n+    // Gas constants\n+    const Rd = 287.058; // J/(kg·K) - Specific gas constant for dry air\n+    const Rv = 461.495; // J/(kg·K) - Specific gas constant for water vapor\n+    \n+    // Convert temperature to Kelvin\n+    const tempK = tempC + 273.15;\n+    \n+    // Calculate air density using the enhanced equation that accounts for humidity\n+    const density = (pressurePA - (vp * 100)) / (Rd * tempK) + (vp * 100) / (Rv * tempK);\n+    \n+    return Math.round(density * 1000) / 1000; // Round to 3 decimal places\n+  }\n+\n+  private transformWeatherData(data: any): EnvironmentalConditions {\n+    // Ensure we're working with numbers\n+    const temperature = Number(data.temperature);\n+    const humidity = Number(data.humidity);\n+    const pressure = Number(data.pressure);\n+    const windSpeed = Number(data.windSpeed);\n+    const windDirection = Number(data.windDirection);\n+    \n+    // Get altitude from geolocation or default to sea level for Jacksonville\n+    const altitude = 10; // Jacksonville is near sea level\n+    \n+    // Calculate density first\n+    const density = this.calculateAirDensity({\n+      temperature,\n+      humidity,\n+      pressure,\n+      altitude,\n+      windSpeed,\n+      windDirection,\n+      density: 0 // Temporary value, not used in calculation\n+    });\n+    \n+    // Return the complete conditions object\n+    return {\n+      temperature,\n+      humidity,\n+      pressure,\n+      altitude,\n+      windSpeed,\n+      windDirection,\n+      density\n+    };\n+  }\n+}\n+\n+export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736987327419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -467,466 +467,4 @@\n   }\n }\n \n export const environmentalService = EnvironmentalService.getInstance()\n-'use client'\n-\n-import { EnvironmentalConditions, EnvironmentalCalculator } from './environmental-calculations'\n-\n-interface SubscriberCallback {\n-  (conditions: EnvironmentalConditions): void\n-}\n-\n-export class EnvironmentalService {\n-  private static instance: EnvironmentalService\n-  private conditions: EnvironmentalConditions\n-  private subscribers: Set<(conditions: EnvironmentalConditions) => void>\n-  private updateInterval: NodeJS.Timeout | null\n-  private baseAltitude: number // Base altitude that stays constant\n-  private lastUpdate: number // Last update timestamp\n-\n-  private constructor() {\n-    // Generate a stable random base altitude using a fixed seed\n-    this.baseAltitude = 100 + Math.floor(Math.random() * 1000)\n-    this.conditions = {\n-      temperature: 70, // °F\n-      humidity: 60,\n-      pressure: 1013.25,\n-      altitude: this.baseAltitude,\n-      windSpeed: 5,\n-      windDirection: 0,\n-      density: 1.225\n-    }\n-    this.subscribers = new Set()\n-    this.updateInterval = null\n-    this.lastUpdate = Date.now()\n-  }\n-\n-  public static getInstance(): EnvironmentalService {\n-    if (!EnvironmentalService.instance) {\n-      EnvironmentalService.instance = new EnvironmentalService()\n-    }\n-    return EnvironmentalService.instance\n-  }\n-\n-  public subscribe(callback: SubscriberCallback): () => void {\n-    this.subscribers.add(callback)\n-    callback(this.conditions)\n-    return () => {\n-      this.subscribers.delete(callback)\n-    }\n-  }\n-\n-  private notifySubscribers(): void {\n-    this.subscribers.forEach((callback) => callback(this.conditions))\n-  }\n-\n-  private async updateConditions(): Promise<void> {\n-    try {\n-      const conditions = await this.getCurrentConditions();\n-      this.conditions = {\n-        ...this.conditions,\n-        temperature: conditions.temperature,\n-        humidity: conditions.humidity,\n-        pressure: conditions.pressure,\n-        windSpeed: conditions.windSpeed,\n-        windDirection: conditions.windDirection,\n-        density: conditions.density\n-      };\n-      \n-      this.lastUpdate = Date.now();\n-      this.notifySubscribers();\n-    } catch (error) {\n-      console.error('Failed to update conditions:', error);\n-      // Keep using previous conditions if API fails\n-    }\n-  }\n-\n-  public startMonitoring(): void {\n-    if (!this.updateInterval) {\n-      this.updateInterval = setInterval(async () => {\n-        try {\n-          await this.updateConditions();\n-        } catch (error) {\n-          console.error('Error in monitoring interval:', error);\n-        }\n-      }, 1000 * 60 * 5); // Update every 5 minutes to avoid excessive API calls\n-      this.updateConditions(); // Initial update\n-    }\n-  }\n-\n-  public stopMonitoring(): void {\n-    if (this.updateInterval) {\n-      clearInterval(this.updateInterval)\n-      this.updateInterval = null\n-    }\n-  }\n-\n-  public getConditions(): EnvironmentalConditions {\n-    return { ...this.conditions }\n-  }\n-\n-  public calculateWindEffect(\n-    shotDirection: number\n-  ): { headwind: number; crosswind: number } {\n-    return EnvironmentalCalculator.calculateWindEffect(\n-      this.conditions.windSpeed,\n-      this.conditions.windDirection,\n-      shotDirection\n-    )\n-  }\n-\n-  public calculateAltitudeEffect(): number {\n-    return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n-  }\n-\n-  async getCurrentConditions(): Promise<EnvironmentalConditions> {\n-    const apiKey = process.env.NEXT_PUBLIC_TOMORROW_API_KEY;\n-    if (!apiKey) {\n-      throw new Error('Tomorrow.io API key not configured. Please set NEXT_PUBLIC_TOMORROW_API_KEY in .env');\n-    }\n-\n-    // Get user's location\n-    let location = { lat: 42.36, lng: -71.06 }; // Default to Boston\n-    let locationSource = 'default';\n-    let ipData: any;\n-\n-    // Try to get cached location first\n-    try {\n-      const cachedLocation = localStorage.getItem('user-location');\n-      if (cachedLocation) {\n-        const { timestamp, data, source } = JSON.parse(cachedLocation);\n-        // Use cache if less than 30 minutes old\n-        if (Date.now() - timestamp < 30 * 60 * 1000) {\n-          location = data;\n-          locationSource = source;\n-          console.log('Using cached location:', location);\n-          console.log('Cache age:', Math.round((Date.now() - timestamp) / 1000 / 60), 'minutes');\n-        }\n-      }\n-    } catch (error) {\n-      console.warn('Failed to read cached location:', error);\n-    }\n-\n-    // Only try to get new location if we don't have a recent cached one\n-    if (locationSource === 'default') {\n-      try {\n-        console.log('Attempting to get precise location via Geolocation API...');\n-        const pos = await new Promise<GeolocationPosition>((resolve, reject) => {\n-          if (!navigator.geolocation) {\n-            reject(new Error('Geolocation not supported'));\n-            return;\n-          }\n-          \n-          // First try with high accuracy\n-          navigator.geolocation.getCurrentPosition(\n-            (position) => {\n-              console.log('Got high accuracy position:', position);\n-              resolve(position);\n-            },\n-            (error) => {\n-              console.warn('High accuracy position failed:', error);\n-              // If high accuracy fails, try with lower accuracy\n-              navigator.geolocation.getCurrentPosition(\n-                resolve,\n-                reject,\n-                {\n-                  enableHighAccuracy: false,\n-                  timeout: 10000,\n-                  maximumAge: 300000\n-                }\n-              );\n-            },\n-            {\n-              enableHighAccuracy: true,\n-              timeout: 10000,\n-              maximumAge: 300000\n-            }\n-          );\n-        });\n-\n-        // Validate coordinates are reasonable\n-        if (pos.coords.latitude >= -90 && pos.coords.latitude <= 90 &&\n-            pos.coords.longitude >= -180 && pos.coords.longitude <= 180 &&\n-            pos.coords.accuracy < 10000) { // Accuracy better than 10km\n-          location = { lat: pos.coords.latitude, lng: pos.coords.longitude };\n-          locationSource = 'geolocation';\n-          console.log('Successfully got precise location:', location);\n-          console.log('Accuracy:', pos.coords.accuracy, 'meters');\n-          \n-          // Get city name for GPS coordinates\n-          try {\n-            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode?latitude=${location.lat}&longitude=${location.lng}&localityLanguage=en&key=bdc_1234567890`);\n-            if (response.ok) {\n-              const geocodeData = await response.json();\n-              console.log('Location details:', {\n-                city: geocodeData.city,\n-                locality: geocodeData.locality,\n-                county: geocodeData.localityInfo?.administrative?.[2]?.name,\n-                state: geocodeData.principalSubdivision,\n-                country: geocodeData.countryName\n-              });\n-            }\n-          } catch (geocodeError) {\n-            console.warn('Failed to get city name:', geocodeError);\n-          }\n-          \n-          // Cache the successful location\n-          localStorage.setItem('user-location', JSON.stringify({\n-            timestamp: Date.now(),\n-            data: location,\n-            source: locationSource,\n-            accuracy: pos.coords.accuracy\n-          }));\n-        } else {\n-          throw new Error(`Invalid or inaccurate coordinates: ${JSON.stringify(pos.coords)}`);\n-        }\n-      } catch (error) {\n-        console.warn('Failed to get precise location:', error);\n-        \n-        // Try to get location from IP as fallback\n-        try {\n-          console.log('Attempting to get location from IP address...');\n-          // Try multiple IP geolocation services in case one fails\n-          const services = [\n-            {\n-              url: 'https://api.bigdatacloud.net/data/reverse-geocode-client',\n-              transform: (data: any) => ({\n-                lat: data.latitude,\n-                lng: data.longitude,\n-                city: data.city,\n-                region: data.principalSubdivision,\n-                accuracy: data.accuracyRadius\n-              })\n-            },\n-            {\n-              url: 'https://ipapi.co/json',\n-              transform: (data: any) => ({\n-                lat: data.latitude,\n-                lng: data.longitude,\n-                city: data.city,\n-                region: data.region,\n-                accuracy: 25000 // Typical IP geolocation accuracy in meters\n-              })\n-            },\n-            {\n-              url: 'https://ipinfo.io/json?token=8b89ef2959c1de5c835ac05cb77ced7f',\n-              transform: (data: any) => ({\n-                lat: parseFloat(data.loc.split(',')[0]),\n-                lng: parseFloat(data.loc.split(',')[1]),\n-                city: data.city,\n-                region: data.region,\n-                accuracy: 25000\n-              })\n-            }\n-          ];\n-\n-          let bestLocation = null;\n-          let bestAccuracy = Infinity;\n-\n-          for (const service of services) {\n-            try {\n-              console.log(`Trying ${service.url}...`);\n-              const response = await fetch(service.url);\n-              if (!response.ok) {\n-                console.warn(`Service ${service.url} returned ${response.status}`);\n-                continue;\n-              }\n-              \n-              ipData = await response.json();\n-              console.log(`Response from ${service.url}:`, ipData);\n-              \n-              const transformed = service.transform(ipData);\n-              \n-              // Validate coordinates\n-              if (transformed.lat >= -90 && transformed.lat <= 90 &&\n-                  transformed.lng >= -180 && transformed.lng <= 180) {\n-                // Keep track of the most accurate result\n-                if (transformed.accuracy < bestAccuracy) {\n-                  bestLocation = transformed;\n-                  bestAccuracy = transformed.accuracy;\n-                }\n-              } else {\n-                console.warn(`Invalid coordinates from ${service.url}:`, transformed);\n-              }\n-            } catch (serviceError) {\n-              console.warn(`Failed to get location from ${service.url}:`, serviceError);\n-              continue;\n-            }\n-          }\n-\n-          if (bestLocation) {\n-            location = { lat: bestLocation.lat, lng: bestLocation.lng };\n-            locationSource = 'ip';\n-            console.log('Using most accurate IP location:', location);\n-            console.log('Accuracy:', bestAccuracy, 'meters');\n-            console.log('City:', bestLocation.city, 'Region:', bestLocation.region);\n-          } else {\n-            throw new Error('No valid location from any IP service');\n-          }\n-        } catch (ipError) {\n-          console.warn('Failed to get location from IP, using default:', ipError);\n-          locationSource = 'default';\n-        }\n-      }\n-    }\n-    \n-    console.group('Location Detection');\n-    console.log(`Source: ${locationSource}`);\n-    console.log('Coordinates:', location);\n-    if (locationSource === 'ip' && ipData) {\n-      console.log('City:', ipData.city, 'Region:', ipData.region);\n-    }\n-    console.groupEnd();\n-    console.log('Fetching weather for coordinates:', location);\n-\n-    const url = `https://api.tomorrow.io/v4/weather/realtime?location=${location.lat},${location.lng}&fields=temperature,humidity,windSpeed,windDirection,pressure&units=imperial&apikey=${apiKey}`;\n-\n-    // Cache weather data for 5 minutes to avoid excessive API calls\n-    const cacheKey = `weather-${location.lat}-${location.lng}`;\n-    const cachedData = localStorage.getItem(cacheKey);\n-    \n-    if (cachedData) {\n-      const { timestamp, data } = JSON.parse(cachedData);\n-      if (Date.now() - timestamp < 5 * 60 * 1000) {\n-        console.log('Using cached weather data:', data);\n-        return this.transformWeatherData(data);\n-      }\n-    }\n-\n-    try {\n-      console.log('Fetching fresh weather data from Tomorrow.io...');\n-      const response = await fetch(url);\n-      if (!response.ok) {\n-        throw new Error(`API request failed with status ${response.status}`);\n-      }\n-      \n-      const data = await response.json();\n-      console.log('Raw weather response:', data);\n-      \n-      const values = data?.data?.values;\n-      if (!values) {\n-        throw new Error('Invalid weather data received');\n-      }\n-\n-      // Validate weather data\n-      if (typeof values.temperature !== 'number' || \n-          values.temperature < -100 || \n-          values.temperature > 150) {\n-        throw new Error(`Invalid temperature value: ${values.temperature}°F`);\n-      }\n-\n-      if (typeof values.humidity !== 'number' || \n-          values.humidity < 0 || \n-          values.humidity > 100) {\n-        throw new Error(`Invalid humidity value: ${values.humidity}%`);\n-      }\n-\n-      if (typeof values.pressure !== 'number' || \n-          values.pressure < 800 || \n-          values.pressure > 1200) {\n-        throw new Error(`Invalid pressure value: ${values.pressure} mb`);\n-      }\n-\n-      // Cache the successful response\n-      localStorage.setItem(cacheKey, JSON.stringify({\n-        timestamp: Date.now(),\n-        data: values\n-      }));\n-\n-      console.group('Weather Data');\n-      console.log('Temperature:', values.temperature, '°F');\n-      console.log('Humidity:', values.humidity, '%');\n-      console.log('Pressure:', values.pressure, 'mb');\n-      console.log('Wind Speed:', values.windSpeed, 'mph');\n-      console.log('Wind Direction:', values.windDirection, '°');\n-      console.groupEnd();\n-\n-      const transformed = this.transformWeatherData(values);\n-      console.log('Transformed weather data:', transformed);\n-      return transformed;\n-    } catch (error) {\n-      console.error('Failed to fetch weather data:', error);\n-      \n-      // If we have cached data, use it even if it's stale\n-      if (cachedData) {\n-        const { data } = JSON.parse(cachedData);\n-        console.warn('Using stale cached weather data due to API error');\n-        return this.transformWeatherData(data);\n-      }\n-      \n-      // If all else fails, return reasonable defaults for Jacksonville, FL\n-      console.warn('Using default weather data');\n-      return {\n-        temperature: 75, // °F\n-        humidity: 70, // %\n-        pressure: 1013.25, // mb (standard sea level pressure)\n-        altitude: 10, // ft (Jacksonville is near sea level)\n-        windSpeed: 8, // mph (typical coastal breeze)\n-        windDirection: 90, // ° (typical easterly wind from Atlantic)\n-        density: this.calculateAirDensity({\n-          temperature: 75,\n-          humidity: 70,\n-          pressure: 1013.25,\n-          altitude: 10,\n-          windSpeed: 8,\n-          windDirection: 90\n-        })\n-      };\n-    }\n-  }\n-\n-  private calculateAirDensity(conditions: EnvironmentalConditions): number {\n-    // Convert units for density calculation\n-    const tempC = (conditions.temperature - 32) * 5/9; // °F to °C\n-    const pressurePA = conditions.pressure * 100; // mb to Pa\n-    \n-    // Calculate saturation vapor pressure using Magnus formula\n-    const a = 6.1121; // mb\n-    const b = 17.368;\n-    const c = 238.88; // °C\n-    const svp = a * Math.exp((b * tempC) / (c + tempC));\n-    \n-    // Calculate actual vapor pressure\n-    const vp = svp * (conditions.humidity / 100);\n-    \n-    // Gas constants\n-    const Rd = 287.058; // J/(kg·K) - Specific gas constant for dry air\n-    const Rv = 461.495; // J/(kg·K) - Specific gas constant for water vapor\n-    \n-    // Convert temperature to Kelvin\n-    const tempK = tempC + 273.15;\n-    \n-    // Calculate air density using the enhanced equation that accounts for humidity\n-    const density = (pressurePA - (vp * 100)) / (Rd * tempK) + (vp * 100) / (Rv * tempK);\n-    \n-    return Math.round(density * 1000) / 1000; // Round to 3 decimal places\n-  }\n-\n-  private transformWeatherData(data: any): EnvironmentalConditions {\n-    // Ensure we're working with numbers\n-    const temperature = Number(data.temperature);\n-    const humidity = Number(data.humidity);\n-    const pressure = Number(data.pressure);\n-    const windSpeed = Number(data.windSpeed);\n-    const windDirection = Number(data.windDirection);\n-    \n-    // Get altitude from geolocation or default to sea level for Jacksonville\n-    const altitude = 10; // Jacksonville is near sea level\n-    \n-    const conditions = {\n-      temperature,\n-      humidity,\n-      pressure,\n-      altitude,\n-      windSpeed,\n-      windDirection,\n-      density: 0 // Will be calculated below\n-    };\n-    \n-    conditions.density = this.calculateAirDensity(conditions);\n-    \n-    return conditions;\n-  }\n-}\n-\n-export const environmentalService = EnvironmentalService.getInstance()\n"
                },
                {
                    "date": 1736987374279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,12 +315,25 @@\n     const cacheKey = `weather-${location.lat}-${location.lng}`;\n     const cachedData = localStorage.getItem(cacheKey);\n     \n     if (cachedData) {\n-      const { timestamp, data } = JSON.parse(cachedData);\n-      if (Date.now() - timestamp < 5 * 60 * 1000) {\n-        console.log('Using cached weather data:', data);\n-        return this.transformWeatherData(data);\n+      try {\n+        const { timestamp, data } = JSON.parse(cachedData);\n+        // Validate cached data\n+        if (Date.now() - timestamp < 5 * 60 * 1000 && \n+            typeof data.temperature === 'number' &&\n+            data.temperature > -50 && data.temperature < 150 &&\n+            typeof data.humidity === 'number' &&\n+            data.humidity >= 0 && data.humidity <= 100) {\n+          console.log('Using cached weather data:', data);\n+          return this.transformWeatherData(data);\n+        } else {\n+          console.log('Cached weather data is invalid or expired, clearing cache');\n+          localStorage.removeItem(cacheKey);\n+        }\n+      } catch (error) {\n+        console.warn('Failed to parse cached weather data:', error);\n+        localStorage.removeItem(cacheKey);\n       }\n     }\n \n     try {\n@@ -339,9 +352,9 @@\n       }\n \n       // Validate weather data\n       if (typeof values.temperature !== 'number' || \n-          values.temperature < -100 || \n+          values.temperature < -50 || \n           values.temperature > 150) {\n         throw new Error(`Invalid temperature value: ${values.temperature}°F`);\n       }\n \n@@ -359,9 +372,15 @@\n \n       // Cache the successful response\n       localStorage.setItem(cacheKey, JSON.stringify({\n         timestamp: Date.now(),\n-        data: values\n+        data: {\n+          temperature: values.temperature,\n+          humidity: values.humidity,\n+          pressure: values.pressure,\n+          windSpeed: values.windSpeed,\n+          windDirection: values.windDirection\n+        }\n       }));\n \n       console.group('Weather Data');\n       console.log('Temperature:', values.temperature, '°F');\n"
                },
                {
                    "date": 1736987895198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -347,51 +347,53 @@\n       console.log('Raw weather response:', data);\n       \n       const values = data?.data?.values;\n       if (!values) {\n-        throw new Error('Invalid weather data received');\n+        throw new Error('Invalid weather data received - no values object');\n       }\n \n-      // Validate weather data\n-      if (typeof values.temperature !== 'number' || \n-          values.temperature < -50 || \n-          values.temperature > 150) {\n-        throw new Error(`Invalid temperature value: ${values.temperature}°F`);\n+      console.log('Weather values from API:', values);\n+\n+      // Extract and validate each field with fallbacks\n+      const weatherData = {\n+        temperature: typeof values.temperature === 'number' ? values.temperature : 75,\n+        humidity: typeof values.humidity === 'number' ? values.humidity : 70,\n+        pressure: typeof values.pressureSeaLevel === 'number' ? values.pressureSeaLevel : 1013.25,\n+        windSpeed: typeof values.windSpeed === 'number' ? values.windSpeed : 8,\n+        windDirection: typeof values.windDirection === 'number' ? values.windDirection : 90\n+      };\n+\n+      // Validate ranges\n+      if (weatherData.temperature < -50 || weatherData.temperature > 150) {\n+        console.warn(`Invalid temperature: ${weatherData.temperature}°F, using default`);\n+        weatherData.temperature = 75;\n       }\n \n-      if (typeof values.humidity !== 'number' || \n-          values.humidity < 0 || \n-          values.humidity > 100) {\n-        throw new Error(`Invalid humidity value: ${values.humidity}%`);\n+      if (weatherData.humidity < 0 || weatherData.humidity > 100) {\n+        console.warn(`Invalid humidity: ${weatherData.humidity}%, using default`);\n+        weatherData.humidity = 70;\n       }\n \n-      if (typeof values.pressure !== 'number' || \n-          values.pressure < 800 || \n-          values.pressure > 1200) {\n-        throw new Error(`Invalid pressure value: ${values.pressure} mb`);\n+      if (weatherData.pressure < 800 || weatherData.pressure > 1200) {\n+        console.warn(`Invalid pressure: ${weatherData.pressure} mb, using default`);\n+        weatherData.pressure = 1013.25;\n       }\n \n-      // Cache the successful response\n+      // Cache the validated data\n       localStorage.setItem(cacheKey, JSON.stringify({\n         timestamp: Date.now(),\n-        data: {\n-          temperature: values.temperature,\n-          humidity: values.humidity,\n-          pressure: values.pressure,\n-          windSpeed: values.windSpeed,\n-          windDirection: values.windDirection\n-        }\n+        data: weatherData\n       }));\n \n       console.group('Weather Data');\n-      console.log('Temperature:', values.temperature, '°F');\n-      console.log('Humidity:', values.humidity, '%');\n-      console.log('Pressure:', values.pressure, 'mb');\n-      console.log('Wind Speed:', values.windSpeed, 'mph');\n-      console.log('Wind Direction:', values.windDirection, '°');\n+      console.log('Temperature:', weatherData.temperature, '°F');\n+      console.log('Humidity:', weatherData.humidity, '%');\n+      console.log('Pressure:', weatherData.pressure, 'mb');\n+      console.log('Wind Speed:', weatherData.windSpeed, 'mph');\n+      console.log('Wind Direction:', weatherData.windDirection, '°');\n       console.groupEnd();\n \n-      const transformed = this.transformWeatherData(values);\n+      const transformed = this.transformWeatherData(weatherData);\n       console.log('Transformed weather data:', transformed);\n       return transformed;\n     } catch (error) {\n       console.error('Failed to fetch weather data:', error);\n"
                }
            ],
            "date": 1736980309721,
            "name": "Commit-0",
            "content": "'use client'\n\nimport { EnvironmentalConditions, EnvironmentalCalculator } from './environmental-calculations'\n\ninterface SubscriberCallback {\n  (conditions: EnvironmentalConditions): void\n}\n\nexport class EnvironmentalService {\n  private static instance: EnvironmentalService\n  private conditions: EnvironmentalConditions\n  private subscribers: Set<(conditions: EnvironmentalConditions) => void>\n  private updateInterval: NodeJS.Timeout | null\n  private baseAltitude: number // Base altitude that stays constant\n  private lastUpdate: number // Last update timestamp\n\n  private constructor() {\n    // Generate a stable random base altitude using a fixed seed\n    this.baseAltitude = 100 + Math.floor(Math.random() * 1000)\n    this.conditions = {\n      temperature: 70, // °F\n      humidity: 60,\n      pressure: 1013.25,\n      altitude: this.baseAltitude,\n      windSpeed: 5,\n      windDirection: 0,\n      density: 1.225\n    }\n    this.subscribers = new Set()\n    this.updateInterval = null\n    this.lastUpdate = Date.now()\n  }\n\n  public static getInstance(): EnvironmentalService {\n    if (!EnvironmentalService.instance) {\n      EnvironmentalService.instance = new EnvironmentalService()\n    }\n    return EnvironmentalService.instance\n  }\n\n  public subscribe(callback: SubscriberCallback): () => void {\n    this.subscribers.add(callback)\n    callback(this.conditions)\n    return () => {\n      this.subscribers.delete(callback)\n    }\n  }\n\n  private notifySubscribers(): void {\n    this.subscribers.forEach((callback) => callback(this.conditions))\n  }\n\n  private updateConditions(): void {\n    const now = Date.now()\n    const timeScale = now / (24 * 60 * 60 * 1000) // Scale to one day\n\n    // Update conditions with some natural variation\n    this.conditions = {\n      ...this.conditions,\n      temperature: 70 + Math.sin(timeScale * Math.PI * 2) * 10, // Vary between 60-80°F\n      humidity: 60 + Math.sin(timeScale * Math.PI * 2 + 1) * 20, // Vary between 40-80%\n      altitude: this.baseAltitude + Math.sin(timeScale * Math.PI * 2 + 2) * 10, // Small variations\n      pressure: 1013.25 + Math.sin(timeScale * Math.PI * 2 + 3) * 10, // Vary around standard\n      windSpeed: Math.abs(Math.sin(timeScale * Math.PI * 2 + 4) * 15), // Vary between 0-15 mph\n      windDirection: (Math.sin(timeScale * Math.PI * 2 + 5) * 180 + 180) % 360, // Vary between 0-360 degrees\n      density: 0 // Will be calculated below\n    }\n\n    // Calculate air density\n    this.conditions.density = EnvironmentalCalculator.calculateAirDensity(this.conditions)\n\n    this.lastUpdate = now\n    this.notifySubscribers()\n  }\n\n  public startMonitoring(): void {\n    if (!this.updateInterval) {\n      this.updateInterval = setInterval(() => this.updateConditions(), 1000)\n      this.updateConditions() // Initial update\n    }\n  }\n\n  public stopMonitoring(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval)\n      this.updateInterval = null\n    }\n  }\n\n  public getConditions(): EnvironmentalConditions {\n    return { ...this.conditions }\n  }\n\n  public calculateWindEffect(\n    shotDirection: number\n  ): { headwind: number; crosswind: number } {\n    return EnvironmentalCalculator.calculateWindEffect(\n      this.conditions.windSpeed,\n      this.conditions.windDirection,\n      shotDirection\n    )\n  }\n\n  public calculateAltitudeEffect(): number {\n    return EnvironmentalCalculator.calculateAltitudeEffect(this.conditions.altitude)\n  }\n\n  async getCurrentConditions(): Promise<EnvironmentalConditions> {\n    const apiKey = process.env.TOMORROW_API_KEY;\n    if (!apiKey) {\n      throw new Error('Tomorrow.io API key not configured');\n    }\n\n    const url = `https://api.tomorrow.io/v4/timelines?location=42.36,-71.06&fields=temperature,humidity,windSpeed,windDirection,pressure&timesteps=current&units=imperial&apikey=${apiKey}`;\n\n    try {\n      const response = await fetch(url);\n      const data = await response.json();\n      \n      const current = data?.data?.timelines[0]?.intervals[0]?.values;\n      if (!current) {\n        throw new Error('Invalid weather data received');\n      }\n\n      return {\n        temperature: current.temperature,\n        humidity: current.humidity,\n        altitude: this.conditions.altitude, // Keep using local altitude\n        windSpeed: current.windSpeed,\n        windDirection: current.windDirection,\n        pressure: current.pressure,\n        density: EnvironmentalCalculator.calculateAirDensity({\n          temperature: current.temperature,\n          humidity: current.humidity,\n          pressure: current.pressure,\n          altitude: this.conditions.altitude,\n          windSpeed: current.windSpeed,\n          windDirection: current.windDirection,\n          density: 1.225\n        })\n      };\n    } catch (error) {\n      console.error('Failed to fetch weather data:', error);\n      throw error;\n    }\n  }\n}\n\nexport const environmentalService = EnvironmentalService.getInstance()\n"
        }
    ]
}