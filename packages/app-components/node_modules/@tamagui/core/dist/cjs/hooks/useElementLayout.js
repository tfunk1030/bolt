var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useElementLayout_exports = {};
__export(useElementLayout_exports, {
  measureElement: () => measureElement,
  measureLayout: () => measureLayout,
  useElementLayout: () => useElementLayout
});
module.exports = __toCommonJS(useElementLayout_exports);
var import_constants = require("@tamagui/constants"), import_getBoundingClientRect = require("../helpers/getBoundingClientRect");
const LayoutHandlers = /* @__PURE__ */ new WeakMap(), resizeListeners = /* @__PURE__ */ new Set();
let resizeObserver = null;
if (typeof window < "u" && "ResizeObserver" in window && (resizeObserver = new ResizeObserver((entries) => {
  for (const { target } of entries) {
    const onLayout = LayoutHandlers.get(target);
    if (typeof onLayout != "function") return;
    measureElement(target).then((event) => {
      onLayout(event);
    });
  }
}), typeof window.addEventListener == "function")) {
  let tm;
  window.addEventListener("resize", () => {
    clearTimeout(tm), tm = setTimeout(() => {
      resizeListeners.forEach((cb) => cb());
    }, 4);
  });
}
const measureElement = async (target) => new Promise((res) => {
  measureLayout(target, null, (x, y, width, height, left, top) => {
    res({
      nativeEvent: {
        layout: { x, y, width, height, left, top },
        target
      },
      timeStamp: Date.now()
    });
  });
}), cache = /* @__PURE__ */ new WeakMap(), measureLayout = (node, relativeTo, callback) => {
  const relativeNode = relativeTo || node?.parentNode;
  if (relativeNode instanceof HTMLElement) {
    const now = Date.now();
    cache.set(node, now), Promise.all([
      getBoundingClientRectAsync(node),
      getBoundingClientRectAsync(relativeNode)
    ]).then(([nodeDim, relativeNodeDim]) => {
      if (relativeNodeDim && nodeDim && cache.get(node) === now) {
        const { x, y, width, height, left, top } = getRelativeDimensions(
          nodeDim,
          relativeNodeDim
        );
        callback(x, y, width, height, left, top);
      }
    });
  }
}, getRelativeDimensions = (a, b) => {
  const { height, left, top, width } = a, x = left - b.left, y = top - b.top;
  return { x, y, width, height, left, top };
}, getBoundingClientRectAsync = (element) => new Promise((resolve) => {
  function fallbackToSync() {
    resolve((0, import_getBoundingClientRect.getBoundingClientRect)(element));
  }
  const tm = setTimeout(fallbackToSync, 10);
  new IntersectionObserver(
    (entries, ob) => {
      clearTimeout(tm), ob.disconnect(), resolve(entries[0]?.boundingClientRect);
    },
    {
      threshold: 1e-4
    }
  ).observe(element);
});
function useElementLayout(ref, onLayout) {
  const node = ref.current?.host;
  node && onLayout && LayoutHandlers.set(node, onLayout), (0, import_constants.useIsomorphicLayoutEffect)(() => {
    if (!resizeObserver || !onLayout) return;
    const node2 = ref.current?.host;
    if (!node2) return;
    LayoutHandlers.set(node2, onLayout);
    const onResize = () => {
      measureElement(node2).then(onLayout);
    };
    return resizeListeners.add(onResize), resizeObserver.observe(node2), () => {
      LayoutHandlers.delete(node2), resizeListeners.delete(onResize), resizeObserver?.unobserve(node2);
    };
  }, [ref, !!onLayout]);
}
//# sourceMappingURL=useElementLayout.js.map
