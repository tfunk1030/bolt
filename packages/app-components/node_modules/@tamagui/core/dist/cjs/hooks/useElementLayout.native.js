"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useElementLayout_exports = {};
__export(useElementLayout_exports, {
  measureElement: () => measureElement,
  measureLayout: () => measureLayout,
  useElementLayout: () => useElementLayout
});
module.exports = __toCommonJS(useElementLayout_exports);
var import_constants = require("@tamagui/constants"), import_getBoundingClientRect = require("../helpers/getBoundingClientRect");
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var LayoutHandlers = /* @__PURE__ */ new WeakMap(), resizeListeners = /* @__PURE__ */ new Set(), resizeObserver = null;
if (typeof window < "u" && "ResizeObserver" in window && (resizeObserver = new ResizeObserver(function(entries) {
  var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _loop = function() {
      var { target } = _step.value, onLayout = LayoutHandlers.get(target);
      if (typeof onLayout != "function") return {
        v: void 0
      };
      measureElement(target).then(function(event) {
        onLayout(event);
      });
    }, _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var _ret = _loop();
      if (_type_of(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
}), typeof window.addEventListener == "function")) {
  var tm;
  window.addEventListener("resize", function() {
    clearTimeout(tm), tm = setTimeout(function() {
      resizeListeners.forEach(function(cb) {
        return cb();
      });
    }, 4);
  });
}
var measureElement = async function(target) {
  return new Promise(function(res) {
    measureLayout(target, null, function(x, y, width, height, left, top) {
      res({
        nativeEvent: {
          layout: {
            x,
            y,
            width,
            height,
            left,
            top
          },
          target
        },
        timeStamp: Date.now()
      });
    });
  });
}, cache = /* @__PURE__ */ new WeakMap(), measureLayout = function(node, relativeTo, callback) {
  var relativeNode = relativeTo || (node == null ? void 0 : node.parentNode);
  if (relativeNode instanceof HTMLElement) {
    var now = Date.now();
    cache.set(node, now), Promise.all([
      getBoundingClientRectAsync(node),
      getBoundingClientRectAsync(relativeNode)
    ]).then(function(param) {
      var [nodeDim, relativeNodeDim] = param;
      if (relativeNodeDim && nodeDim && cache.get(node) === now) {
        var { x, y, width, height, left, top } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    });
  }
}, getRelativeDimensions = function(a, b) {
  var { height, left, top, width } = a, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    left,
    top
  };
}, getBoundingClientRectAsync = function(element) {
  return new Promise(function(resolve) {
    function fallbackToSync() {
      resolve((0, import_getBoundingClientRect.getBoundingClientRect)(element));
    }
    var tm = setTimeout(fallbackToSync, 10), observer = new IntersectionObserver(function(entries, ob) {
      var _entries_;
      clearTimeout(tm), ob.disconnect(), resolve((_entries_ = entries[0]) === null || _entries_ === void 0 ? void 0 : _entries_.boundingClientRect);
    }, {
      threshold: 1e-4
    });
    observer.observe(element);
  });
};
function useElementLayout(ref, onLayout) {
  var _ref_current, node = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host;
  node && onLayout && LayoutHandlers.set(node, onLayout), (0, import_constants.useIsomorphicLayoutEffect)(function() {
    var _ref_current2;
    if (!(!resizeObserver || !onLayout)) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) {
        LayoutHandlers.set(node2, onLayout);
        var onResize = function() {
          measureElement(node2).then(onLayout);
        };
        return resizeListeners.add(onResize), resizeObserver.observe(node2), function() {
          LayoutHandlers.delete(node2), resizeListeners.delete(onResize), resizeObserver == null || resizeObserver.unobserve(node2);
        };
      }
    }
  }, [
    ref,
    !!onLayout
  ]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  measureElement,
  measureLayout,
  useElementLayout
});
//# sourceMappingURL=useElementLayout.js.map
